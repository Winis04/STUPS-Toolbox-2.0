\lstset{
	language=Java,
	breaklines=true,
	commentstyle=\color{green},
	keywordstyle=\color{blue},
	stringstyle=\color{magenta}
}
\section{Architektur und Erweiterung des Programms}\raggedbottom
\label{sec:3}
In diesem Abschnitt geht es um den Aufbau der Toolbox und wie man ihr neue Funktionen und Datentypen hinzufügen kann. Hiefür wird zunächst grob erläutert, wie die Ordnerstruktur des Programms aufgebaut ist und welche Klassen für welche Funktionen zuständig sind. Anschließend wird erläutert, wie Grammatiken und Automaten implementiert sind. Danach wird genauer auf die verschieden Interfaces eingegangen, mit denen neue Plugins erstellt werden können. Zuletzt wird noch erklärt, wie man dem Programm neue Datentypen hinzufügen kann.
\subsection{Aufbau der Toolbox}
\label{sec:3.1}
\paragraph{Wurzelverzeichnis}\ \\
Im Wurzelverzeichnis der Quellen liegen die beiden Java-Klassen \textit{Main.GUI} und \textit{Main.CLI}. Diese beiden Java-Klassen bilden das Hauptprogramm. \textit{Main.GUI} ist dabei die Hauptklasse. Beim Start des Programms initialisiert sie die grafische Oberfläche und lädt alle Grafik-Plugins. Anschließend übergibt sie die Kontrolle an die Klasse \textit{Main.CLI}. Diese lädt dann alle Konsolen-Plugins und startet die Kommandozeile. Nun kann der Benutzer Befehle eingeben. Die Befehle \textit{gui}, \textit{help} und \textit{exit} sind fest in Main.CLI einprogrammiert, alle restlichen kommen von Plugins.
\paragraph{GrammarSimulator}\ \\
Dieses Verzeichnis enthält die Klassen, die eine Grammatik repräsentieren. Dazu gehören die Klasse \textit{Grammar}, welche eine Grammatik darstellt, das Interface \textit{Symbol} und die beiden Klassen \textit{Terminal} und \textit{Nonterminal}, welche \textit{Symbol} implementieren und Terminale, bzw. Nichtterminale repräsentieren.\\
Außerdem enthält dieser Ordner noch die Klasse \textit{GrammarUtil}, die viele Methoden beinhaltet, die mit Grammatiken arbeiten (zum Beispiel um die First- und Follow-Mengen einer Grammatik zu berechnen).
\paragraph{AutomatonSimulator}\ \\
In diesem Ordner befinden sich die Klassen, \textit{Automaton}, welche einen Automaten repräsentiert, \textit{State}, die einen Zustand darstellt und \textit{Rule}, die nötig ist um Produktionen zu speichern.\\
Des Weiteren befindet sich hier noch die Klasse \textit{AutomatonUtil}, die eine ähnliche Funktion wie \textit{GrammarUtil} hat, nur dass diese Algorithmen für Automaten und nicht für Grammatiken beinhaltet.
\paragraph{AutomatonParser und GrammarParser}\ \\
Diese beiden Ordner enthalten die von SableCC generierten Parser für Automaten und Grammatiken. Des Weiteren enthalten beide noch eine \textit{Visitor}-Klasse, welche aus einer geparsten Datei einen Automaten, bzw. eine Grammatik erstellt.
\paragraph{CLIPlugins}\ \\
Hier befindet sich das Interface \textit{CLIPlugin} und alle Konsolen-Plugins. Eine Klasse, die sich in diesem Verzeichnis befindet und das Interface CLIPlugin implementiert, wird von der Klasse \textit{Main.CLI} automatisch zur Laufzeit geladen und kann vom Benutzer in der Konsole ausgeführt werden.
\paragraph{GUIPlugins}\ \\
Dieser Ordner beinhaltet nur die drei Unterverzeichnisse \textit{DisplayPlugins}, \textit{SimpleFunctionsPlugins} und \textit{ComplexFunctionPlugins}, die zusammen alle Plugins für die grafische Oberfläche enthalten.
\paragraph{GUIPlugins/DisplayPlugins}\ \\
Hier befindet das Interface \textit{DisplayPlugin}, sowie alle Klassen die es implementieren. Ein DisplayPlugin hat die Aufgabe einen bestimmten Datentypen grafisch darzustellen. Zu dem Plugin \textit{GrammarGUI}, welches Grammatiken darstellt, gibt es hier zusätzlich noch einen weiteren Unterordner \textit{GrammarTabs}.
\paragraph{DisplayPlugins/GUIPligins/GrammarTabs}\ \\
Wie in Abschnitt \hyperref[sec:2.4.1]{2.4.1} beschrieben, setzt sich die grafische Oberfläche für Grammatiken aus mehreren Tabs zusammen. Hierfür liegt in dem Unterordner \textit{GrammarTabs} das Interface \textit{GrammarTab} mit einigen Klassen, die es implementieren. Für jede dieser Klassen legt die Klasse \textit{GrammarGui} einen Tab in der Oberfläche an.
\paragraph{GUIPlugins/ComplexFunctionPlugins}\ \\
In diesem Verzeichnis liegt das Interface \textit{ComplexFunctionPlugin} zusammen mit den Klassen die es implementieren. Diese werden in der grafischen Oberfläche als die im Abschnitt \hyperref[sec:2.4.2.1]{2.4.2} beschrieben Plugins mit grafischer Oberfläche angezeigt.
\paragraph{GUIPlugins/SimpleFunctionPlugins}\ \\
Dieser Ordner enthält das Interface \textit{SimpleFunctionPlugin} und die Klassen die es implementieren. Diese Klassen werden in der grafischen Oberfläche in dem Dropdown-Menü unten rechts aufgelistet, so wie es im Abschnitt \hyperref[sec:2.4.2.2]{2.4.2} beschrieben wird.
\subsection{Implementierung von Grammatiken und Automaten}
\label{sec:3.2}
\paragraph{Grammatiken}\ \\
Eine Grammatik besteht in meiner Implementierung aus einem \lstinline[columns=fixed]{HashSet} von Nichtterminalen und einem \lstinline[columns=fixed]{HashSet} von Terminalen. Außerdem gibt es ein Nichttterminal, welches als Startsymbol ausgezeichnet ist.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Klasse \textit{Grammar}]
public class Grammar {
	private HashSet<Terminal> terminals;
	private HashSet<Nonterminal> nonterminals;
	private Nonterminal startSymbol;
	
	public Grammar() {
		Terminal terminal = new Terminal("a");
		ArrayList<Symbol> symbolList = new ArrayList(Arrays.asList(terminal));
		this.startSymbol = new Nonterminal("S", new HashSet<>(Arrays.asList(symbolList)));
		this.terminals = new HashSet<>(Arrays.asList(terminal));
		this.nonterminals = new HashSet<>(Arrays.asList(startSymbol));
	}
	
	public Grammar(HashSet<Terminal> terminals, HashSet<Nonterminal> nonterminals, Nonterminal startSymbol) {
		this.terminals = terminals;
		this.nonterminals = nonterminals;
		this.startSymbol = startSymbol;
	}
	
	public HashSet<Terminal> getTerminals() {
		return terminals;
	}
	
	public HashSet<Nonterminal> getNonterminals() {
		return nonterminals;
	}
	
	public Nonterminal getStartSymbol() {
		return startSymbol;
	}
	
	public void setStartSymbol(Nonterminal startSymbol) {
		this.startSymbol = startSymbol;
	}
}
\end{lstlisting}
Wie man sieht, gibt es zwei Konstruktoren. Einen, der keine Parameter nimmt und eine neue Grammatik erstellt, die nur das Nichtterminal \textit{S}, das Terminal \textit{a} und die Produktion \textit{S --> a} beinhaltet. Der zweite Konstruktor bekommt jeweils ein \lstinline[columns=fixed]{HashSet} von Terminalen und Nichtterminalen, sowie ein Nichtterminal, dass als Startsymbol fungieren soll.\\
Terminale und Nichtterminale werden jeweils durch eine eigenständige Klasse repräsentiert. Beide implementieren das Interface \lstinline[columns=fixed]{Symbol}:
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Das Interface \textit{Symbol}]
public interface Symbol {
	String getName();
	void setName(String name);
}
\end{lstlisting}
Das Interface besteht nur aus einer Getter- und einer Setter-Methode für den Namen des \lstinline[columns=fixed]{Symbol}s, welcher in einem String gespeichert wird.\\
Die Klasse \lstinline[columns=fixed]{Terminal} implementiert \lstinline[columns=fixed]{Symbol} folgendermaßen:
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Klasse \textit{Terminal}]
public class Terminal implements Symbol {
	private String name;
	
	public Terminal(String name) {
		this.name = name;
	}
	
	@Override
	public String getName() {
		return name;
	}
	
	@Override
	public void setName(String name) {
		this.name = name;
	}
}
\end{lstlisting}
Ein Terminal hat also nur einen Namen, der in der Variable \lstinline[columns=fixed]{name} gespeichert wird.\\
Ein Nichtterminal hingegen ist ein bisschen komplexer:
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Klasse \textit{Nonterminal}]
public class Nonterminal implements Symbol {
	private String name;
	private HashSet<ArrayList<Symbol>> symbolLists;
	
	public Nonterminal(String name, HashSet<ArrayList<Symbol>> symbolLists) {
		this.name = name;
		this.symbolLists = symbolLists;
	}
	
	@Override
	public String getName() {
		return name;
	}
	
	@Override
	public void setName(String name) {
		this.name = name;
	}
	
	public HashSet<ArrayList<Symbol>> getSymbolLists() {
		return symbolLists;
	}
}
\end{lstlisting}
Zusätzlich zu dem Namen hat ein Nichtterminal noch ein \lstinline[columns=fixed]{HashSet} von \lstinline[columns=fixed]{ArrayLists} des Typs \lstinline[columns=fixed]{Symbol}. Diese Listen können somit sowohl Terminale, als auch Nichtterminale beinhalten und repräsentieren die rechte Seite einer Produktion, welche, wie in Abschnitt \hyperref[sec:1.1]{1.1} beschrieben, aus einer Folge von Terminalen und Nichtterminalen besteht.
\paragraph{Automaten}\ \\
Ein Automat hat ein \lstinline[columns=fixed]{HashSet} von Zuständen, ein \lstinline[columns=fixed]{HashSet} von Strings, wobei jeder String für ein mögliches Eingabesymbol steht, und einen als Startzustand markierten Zustand.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Klasse \textit{Automaton}]
public class Automaton {
	private HashSet<State> states;
	
	private State startState;
	private HashSet<String> allInputs;
	private boolean epsilonCycle = false;
	
	public Automaton(HashSet<State> states, State startState, HashSet<String> allInputs) {
		this.states = states;
		this.startState = startState;
		this.allInputs = allInputs;
		this.removeEpsilonCycles();
		if(epsilonCycle) {
			System.out.println("Epsilon-cycles in this automaton have been removed automatically!");
		}
	}
	
	public Automaton() {
		this.startState = new State("z0", true, false, new HashSet<>());
		this.states = new HashSet<>();
		this.states.add(this.startState);
		this.allInputs = new HashSet<>();
	}
	
	
	private void removeEpsilonCycles() {
		...
	}
	
	private void removeEpsilonCycles(State startState, HashSet<State> visitedStates, boolean cycleFound) {
		...
	}
	
	public HashSet<State> getStates() {
		return states;
	}
	
	public State getStartState() {
		return startState;
	}
	
	public HashSet<String> getAllInputs() {
		return allInputs;
	}
	
	public void setStartState(State startState) {
		this.startState = startState;
	}
}
\end{lstlisting}
Auch hier gibt es zwei Konstruktoren. Wie bei den Grammatiken gibt es einen, der keine Argumente nimmt. Dieser erstellt einen Automaten mit nur einem Zustand (dem Startzustand) und keinen Produktionen. Der andere bekommt eine Menge von Zuständen, eine Menge von möglichen Eingabesymbolen, und einen Startzustand. Mit Hilfe der Methode \lstinline[columns=fixed]{removeEpsilonCycles} werden alle zyklischen Epsilon-Produktionen entfernt (falls es welche gibt). Außerdem gibt es noch Getter-Methoden für die beiden \lstinline[columns=fixed]{HashSet}s und den Startzustand, sowie eine Setter-Methode für den Startzustand.\\
Zustände werden durch die Klasse \lstinline[columns=fixed]{State} repräsentiert:
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Klasse \textit{State}]
public class State {
	private String name;	
	private boolean isStart;	
	private boolean isFinal;	
	private HashSet<Rule> rules;
	
	public State(String name, boolean isStart, boolean isFinal, HashSet<Rule> rules) {
		this.name = name;
		this.isStart = isStart;
		this.isFinal = isFinal;
		this.rules = rules;
	}
	
	public String getName() {
		return name;
	}
	
	public boolean isFinal() {
		return isFinal;
	}
	
	public boolean isStart() {
		return isStart;
	}
	
	public HashSet<Rule> getRules() {
		return rules;
	}
	
	public void setStart(boolean start) {
		isStart = start;
	}
	
	public void setFinal(boolean aFinal) {
		isFinal = aFinal;
	}
	
	public void setName(String name) {
		this.name = name;
	}
}
\end{lstlisting}
Ein Zustand besteht aus einem \lstinline[columns=fixed]{String}, der seinen Namen beinhaltet, zwei \lstinline[columns=fixed]{boolean}-Variablen, mit denen festgehalten wird, ob der Zustand ein Start-, bzw. Endzustand ist, und einem \lstinline[columns=fixed]{HashSet} vom Type \lstinline[columns=fixed]{Rule}, in welchem die Produktionen festgehalten sind, die von diesem Zustand ausgehen. Es gibt nur einen Konstruktor, der für jede der vier Variablen einen Wert übergeben bekommt. Zusätzlich gibt es noch einige Getter- und Setter-Methoden für die Variablen.\\
Produktionen werden durch die Klasse \lstinline[columns=fixed]{Rule} dargestellt:
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Klasse \textit{Rule}]
public class Rule {
	private State goingTo;
	private HashSet<String> acceptedInputs;
	
	public Rule(State goingTo, HashSet<String> acceptedInputs) {
		this.goingTo = goingTo;
		this.acceptedInputs = acceptedInputs;
	}
	
	public State getGoingTo() {
		return goingTo;
	}
	
	public HashSet<String> getAcceptedInputs() {
		return acceptedInputs;
	}
	
	public void setGoingTo(State goingTo) {
		this.goingTo = goingTo;
	}
}
\end{lstlisting}
Eine Produktion besteht einfach nur aus dem Zustand auf den sie zeigt und einem \lstinline[columns=fixed]{HashSet} von Strings. Diese sind die Eingabesymbole, die von dieser Produktion akzeptiert werden.
\subsection{Erweiterung des Funktionsumfangs mit neuen Plugins}
\label{sec:3.3}
\subsubsection{Funktionen zur Kommandozeile hinzufügen mit \textit{CLIPlugin}}
\label{sec:3.3.1}
Um der Kommandozeile eine neue Funktion hinzuzufügen, muss eine neue Klasse im Ordner \textit{CLIPlugins} erstellt werden, die das Interface \lstinline[columns=fixed]{CLIPlugin} implementiert. \lstinline[columns=fixed]{CLIPlugin} besteht aus folgenden Methoden:
\begin{itemize}
	\item \lstinline[columns=fixed]{String[] getNames()}:\\
	Gibt ein Array aus Strings zurück. Wenn der Benutzer einen dieser Strings in die Kommandozeile eingibt, wird das Plugin ausgeführt.
	\item \lstinline[columns=fixed]{boolean checkParameters(String[] parameters)}:\\
	Als Parameter wird hier ein String-Array übergeben, das die Parameter, mit denen der Benutzer den Befehl aufgerufen hat, beinhaltet. Aufgabe dieser Methode ist es, diese auf ihre Gültigkeit zu prüfen und \lstinline[columns=fixed]{true} zurückzugeben, falls alles in Ordnung ist, bzw. \lstinline[columns=fixed]{false}, falls mit den Parametern etwas nicht stimmt.
	\item \lstinline[columns=fixed]{String getHelpText()}:\\
	Gibt den zu diesem Plugin zugehörigen Hilfetext zurück. Dieser wird ausgegeben, wenn der Benutzer den Befehl \textit{help} eintippt.
	\item \lstinline[columns=fixed]{Object execute(Object object, String parameters)}:\\
	Hier wird die eigentliche Funktion des Plugins implementiert. Als erster Parameter wird ein \lstinline[columns=fixed]{Object} übergeben. Dies kann zum Beispiel ein Automat sein und sollte vorher zu seinem eigentlichen Typen konvertiert werden. Der zweite Parameter ist ein \lstinline[columns=fixed]{String}-Array, welches die Parameter enthält, mit denen der Benutzer den Befehl aufgerufen hat. Der Rückgabewert ist auch vom Typ \lstinline[columns=fixed]{Object} und kann zum Beispiel wieder ein Automat sein, der durch das Plugin verändert wurde.
	\item \lstinline[columns=fixed]{Class inputType()}:\\
	Gibt ein Objekt vom Typ \lstinline[columns=fixed]{Class} zurück. Hierbei sollte es sich um den Klassentyp des Objekts handeln, dass die Methode \lstinline[columns=fixed]{execute(Object object, String parameters)} als ersten Parameter bekommen soll.
	\item \lstinline[columns=fixed]{Class outputType()}:\\
	Gibt ebenfalls ein Objekt vom Typ \lstinline[columns=fixed]{Class} zurück. Hierbei sollte es sich nun um den Klassentyp des Objekts handeln, dass \lstinline[columns=fixed]{execute(Object object, String parameters)} zurückgibt.
	\item \lstinline[columns=fixed]{boolean errorFlag()}:\\
	Diese Methode wird vom Hauptprogramm nach der Ausführung von \lstinline[columns=fixed]{execute(Object object, String[] parameters)} aufgerufen und gibt \lstinline[columns=fixed]{true} zurück, wenn die Ausführung erfolgreich war, bzw. \lstinline[columns=fixed]{false}, wenn dabei ein Fehler aufgetreten ist.
\end{itemize}
Zur Verdeutlichung wird nun nochmal anhand der Klasse \textit{AutomatonSavePlugin} gezeigt, wie ein Plugin für die Kommandozeile aussieht:
\lstset{
	language=Java,
	captionpos=b,
	breaklines=true,
	commentstyle=\color{green},
	keywordstyle=\color{blue},
	stringstyle=\color{magenta},
}
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Der Kopf der Klasse \textit{AutomatonSavePlugin}]
public class AutomatonSavePlugin implements CLIPlugin {
	boolean errorFlag = false;
\end{lstlisting}
Wie man hier sieht, implementiert die Klasse \lstinline[columns=fixed]{AutomatonSavePlugin} das Interface \lstinline[columns=fixed]{CLIPlugin}. Als erstes wird dann in dieser Klasse die Variable \lstinline[columns=fixed]{errorFlag} vom Type \lstinline[columns=fixed]{boolean} mit dem Wert \lstinline[columns=fixed]{false} initialisiert. Diese wird später benötigt, um anzugeben, ob während der Ausführung des Plugins ein Fehler aufgetreten ist.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{getNames}]
@Override
public String[] getNames() {
	return new String[]{"sa", "save-automaton"};
}
\end{lstlisting}
Der Rückgabewert dieser Methode ist ein Array von \lstinline[columns=fixed]{String}s und enthält \lstinline[columns=fixed]{"sa"} und \lstinline[columns=fixed]{"save-automaton"}. Wenn der Benutzer einen dieser beiden \lstinline[columns=fixed]{String}s als Befehl in die Kommandozeile eingibt, wird das Plugin ausgeführt.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{checkParameters}]
@Override
public boolean checkParameters(String[] parameters) {
	if(parameters.length < 1) {
		System.out.println("Please enter a filename as parameter for this command!");
		return false;
	}
	return true;
}
\end{lstlisting}
Dieses Plugin erwartet einen Parameter, nämlich den Namen der Datei, bzw. den Pfad zu ihr, in die der aktuell geladene Automat gespeichert werden soll. Wird kein Parameter angegeben, schreibt die Methode eine Fehlermeldung in die Konsole und gibt \lstinline[columns=fixed]{false} zurück. Das Hauptprogramm weiß dann, dass der Benutzer eine fehlerhafte Eingabe gemacht hat und ruft nicht die Methode \lstinline[columns=fixed]{execute(Object object, String[] parameters)} auf. Ist alles in Ordnung, wird \lstinline[columns=fixed]{true} zurückgegeben.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{getHelpText}]
@Override
public String getHelpText() {
	return "Writes the loaded automaton into a text file, which can later be reloaded by this program. Takes a filename as parameter.";
}
\end{lstlisting}
Hier wird der Hilfetext dieses Plugins zurückgegeben.
\newpage
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{execute}]
@Override
public Object execute(Object object, String[] parameters) {
	errorFlag = false;
	if(object == null) {
		System.out.println("Please use 'la', or 'load-automaton' to load an automaton before using this command!");
		errorFlag = true;
		return null;
	}
	Automaton automaton = (Automaton) object;
	AutomatonUtil.save(automaton, parameters[0]);
	return null;
}
\end{lstlisting}
Diese Methode ist das Herzstück des Plugins, da sie die eigentliche Funktion implementiert. Zunächst einmal wird überprüft, ob das übergebene Objekt gleich \lstinline[columns=fixed]{null} ist. Sollte dies der Fall sein, bedeutet das, dass noch kein Automat geladen wurde. Dementsprechend wird eine Fehlermeldung mit dem Hinweis ausgegeben, in dem der Benutzer gebeten wird einen Automaten zu laden, bevor er diesen Befehl benutzt. Anschließend wird die Variable \lstinline[columns=fixed]{errorFlag} auf \lstinline[columns=fixed]{true} gesetzt und \lstinline[columns=fixed]{null} zurückgegeben.\\
Wenn bereits ein Automat geladen wurde, wird \lstinline[columns=fixed]{object} mit einem Typecast zu einem Automaten umgewandelt und mit Hilfe der Methode \lstinline[columns=fixed]{save(Automaton automaton, String filename)} aus der Klasse \lstinline[columns=fixed]{AutomatonUtil} in eine Datei geschrieben. Da dieses Plugin keine Veränderungen an dem Automaten vornimmt, gibt es \lstinline[columns=fixed]{null} zurück.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{inputType}]
@Override
public Class inputType() {
	return Automaton.class;
}
\end{lstlisting}
Da dieses Plugin einen Automaten als ersten Parameter der Methode \lstinline[columns=fixed]{execute(Object object, String[] parameters)} haben möchte, wird hier \lstinline[columns=fixed]{Automaton.class} zurückgegeben.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{outputType}]
@Override
public Class outputType() {
	return null;
}
\end{lstlisting}
Wie oben bereis erwähnt, nimmt dieses Plugin keine Veränderungen an dem übergebenen Automaten vor. Deshalb wird hier einfach nur \lstinline[columns=fixed]{null} zurückgegeben. Dadurch weiß das Hauptprogramm, dass es den Rückgabewert von \lstinline[columns=fixed]{execute(Object object, String[] parameters)} verwerfen soll. Möchte man ein Plugin schreiben, das dauerhafte Veränderungen an einem Objekt vornimmt, so muss \lstinline[columns=fixed]{outputType()} den Typ dieses Objektes zurückgeben (in diesem Fall wäre dass \lstinline[columns=fixed]{Automaton.class}). Natürlich ist es auch möglich, dass ein Plugin zwei voneinander verschiedene Eingabe- und Ausgabetypen hat (zum Beispiel eine Grammatik als Eingabe, und eine Automaten als Ausgabe).
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{errorFlag}]
@Override
public boolean errorFlag() {
	return errorFlag;
}
\end{lstlisting}
Diese Methode gibt einfach nur die Variable \lstinline[columns=fixed]{errorFlag} zurück.
\subsubsection{Erweiterung der grafischen Oberfläche mit \textit{DisplayPlugin}, \textit{SimpleFunctionPlugin} und \textit{ComplexFunctionPlugin}}
\label{sec:3.3.2}
Um der graphischen Oberfläche neue Funktionen hinzuzufügen gibt es drei Plugins.\\ \lstinline[columns=fixed]{DisplayPlugin} ist hierbei das Hauptinterface. Eine Klasse, die es implementiert, soll eine Datenstruktur (zum Beispiel einen Automaten) visuell darstellen und eventuell dem Benutzer die Möglichkeit geben diese zu bearbeiten.\\
Mit \lstinline[columns=fixed]{SimpleFunctionPlugin} und \lstinline[columns=fixed]{ComplexFunctionPlugin} können Funktionen hinzugefügt werden, die mit einer bestimmten Datenstruktur arbeiten (zum Beispiel ein Plugin, das einen Automaten minimiert).
\paragraph{Das Interface DisplayPlugin}\ \\
Um der Toolbox um ein neues \lstinline[columns=fixed]{DisplayPlugin} zu erweitern, muss eine Klasse im Ordner \textit{GUIPlugins/DisplayPlugins} erstellt werden, die \lstinline[columns=fixed]{DisplayPlugin} implementiert. Hierzu müssen folgende Methoden implementiert werden:
\begin{itemize}
	\item \lstinline[columns=fixed]{Node display(Object object)}:\\
	Diese Methode soll das ihr übergebene Objekt auf einem JavaFX-\lstinline[columns=fixed]{Node} visualisieren. Üblicherweise nimmt man hierzu ein \lstinline[columns=fixed]{Pane}, es kann aber irgendein Objekt zurückgegeben werden, das von \lstinline[columns=fixed]{Node} erbt. Somit ist es auch möglich das übergebene Objekt mit Hilfe von Swing darzustellen. Man muss dafür nur das Haupt-\lstinline[columns=fixed]{JPanel} auf ein \lstinline[columns=fixed]{SwingNode} legen.
	\item \lstinline[columns=fixed]{void refresh(Object object)}:\\
	Die \lstinline[columns=fixed]{refresh}-Methode wird vom Hauptprogramm aufgerufen, wenn das Objekt, das von diesem Plugin dargestellt wird, verändert wurde. Die Methode soll dann die Darstellung des Objekts aktualisieren.
	\item \lstinline[columns=fixed]{Object newObject()}:\\
	Diese Methode soll ein neues Objekt erstellen und zurückgeben.
	\item \lstinline[columns=fixed]{Object openFile()}:\\
	Der Benutzer wird gebeten eine Datei zu öffnen (zum Beispiel mit einem \lstinline[columns=fixed]{FileChooser}). Diese Datei soll dann geparst und das resultierende Objekt zurückgegeben werden.
	\item \lstinline[columns=fixed]{void saveFile(Object object)}:\\
	Speichert das übergebene Objekt in einer Datei. Vorher soll der User noch nach dem Pfad und Namen der Datei gefragt werden (zum Beispiel mit einem \lstinline[columns=fixed]{FileChooser}).
	\item \lstinline[columns=fixed]{String getName()}:\\
	Gibt den Namen dieses Plugins als String zurück. Dieser wird im \textit{ChoosePlugin}-Menü angezeigt.
	\item \lstinline[columns=fixed]{Class displayType()}:\\
	Diese Methode gibt den Klassentypen der Objekte zurück, die dieses Plugin darstellen kann.
\end{itemize}
Um detailliert zu zeigen, wie ein solches Plugin implementiert wird, folgt nun ein einfaches Beispiel-Plugin, welches alle Produktion einer Grammatik anzeigt:
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Der Kopf der Klasse \textit{GrammarExample}]
public class GrammarExample implements DisplayPlugin {
	GridPane rootPane;
\end{lstlisting}
Auf dem \lstinline[columns=fixed]{GridPane rootPane} sollen die Produktion dargestellt werden.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{displayRules}]
private void displayRules(Grammar grammar) {
	rootPane.getChildren().clear();
	
	int i = 0;
	for(Nonterminal nonterminal : GrammarUtil.getNonterminalsInOrder(grammar)) {
		for(ArrayList<Symbol> symbolList : nonterminal.getSymbolLists()) {
			StringBuilder sb = new StringBuilder();
			Iterator<Symbol> it = symbolList.iterator();
			while(it.hasNext()) {
			sb.append(it.next().getName());
			if(it.hasNext()) {
				sb.append(", ");
			}
		}
		
		rootPane.add(new Label(nonterminal.getName()), 0, i);
		rootPane.add(new Label("-->"), 1, i);
		rootPane.add(new Label(sb.toString()), 2, i);
		i++;
		}
	}
}
\end{lstlisting}
\lstinline[columns=fixed]{displayRules(Grammar grammar)} ist eine Hilfsmethode, die als Parameter eine Grammatik bekommt und deren Produktionen in Form von \lstinline[columns=fixed]{Label}s auf dem \lstinline[columns=fixed]{rootPane} darstellt. Dabei wird die Methode \lstinline[columns=fixed]{getNonterminalsInOrder(Grammar grammar)} aus der Klasse \lstinline[columns=fixed]{GrammarUtil} verwendet, damit die Produktionen nach den Nichtterminalen, die auf der linken Seite stehen, sortiert sind. Prinzipiell könnte man auch einfach über \lstinline[columns=fixed]{grammar.getNonterminals()} iterieren, jedoch wäre die Reihenfolge der Produktionen dann zufällig.\\
Der Rest der Methode sollte relativ einfach verständlich sein. Für jede Symbolliste auf die ein Nichtterminal zeigt, werden drei Labels angelegt, die den Namen des Nichtterminals, einen Pfeil und die Symbolliste enthalten. Anschließend werden dieses Labels in eine neue Zeile auf dem \lstinline[columns=fixed]{rootPane} gelegt.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{display}]
@Override
public Node display(Object object) {
	Grammar grammar = (Grammar) object;
	rootPane = new GridPane();
	rootPane.setAlignment(Pos.CENTER);
	rootPane.setHgap(10);
	rootPane.setVgap(5);
	displayRules(grammar);
	return rootPane;
}
\end{lstlisting}
Die \lstinline[columns=fixed]{display(Object object)}-Methode wandelt zunächst das ihr übergebene Objekt in eine Grammatik um und initialisiert dann das \lstinline[columns=fixed]{rootPane}. Anschließend werden noch einige Attribute des \lstinline[columns=fixed]{rootPane}s verändert, damit die auf ihm liegenden Objekte zentriert sind und einige Pixel Abstand zueinander haben. Zuletzt wird das \lstinline[columns=fixed]{rootPane} mit Hilfe von \lstinline[columns=fixed]{displayRules(Grammar grammar)} gefüllt und danach zurückgegeben.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{refresh}]
@Override
public void refresh(Object object) {
	displayRules((Grammar) object);
}
\end{lstlisting}
Um die Oberfläche zu aktualisieren, muss \lstinline[columns=fixed]{displayRules(Grammar grammar)} aufgerufen werden.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{newObject}]
@Override
public Object newObject() {
	return new Grammar();
}
\end{lstlisting}
Um eine neue Grammatik zu erzeugen, reicht es den Konstruktor der Klasse \lstinline[columns=fixed]{Grammar} ohne Argumente aufzurufen. Dieser erstellt dann automatisch eine neue Grammatik mit einem Terminal, einem Nichtterminal und einer Produktion.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{openFile}]
@Override
public Object openFile() {
	FileChooser chooser = new FileChooser();
	chooser.setTitle("Open file");
	File selectedFile = chooser.showOpenDialog(new Stage());
	String fileInput = "";
	try {
		BufferedReader reader = new BufferedReader(new FileReader(selectedFile.getName()));
		String line;
		while ((line = reader.readLine()) != null) {
			fileInput = fileInput + line + "\n";
		}
		return GrammarUtil.parse(fileInput);
	} catch (Exception e) {
		Alert alert = new Alert(Alert.AlertType.ERROR);
		alert.setTitle("STUPS-Toolbox");
		alert.setHeaderText("Error while opening the file!");
		alert.showAndWait();
		return null;
	}
}
\end{lstlisting}
In \lstinline[columns=fixed]{openFile()} wird zu Beginn ein FileChooser initialisiert. Im \lstinline[columns=fixed]{try}-Block wird dieser dann angezeigt und der Inhalt der ausgewählten Datei wird in die Variable \lstinline[columns=fixed]{fileInput eingelesen}. Anschließend wird dieser mit der Methode \lstinline[columns=fixed]{parse(String fileInput)} aus der Klasse \lstinline[columns=fixed]{GrammarUtil} zu einer Grammatik geparst. Die Grammatik muss dafür in dem in Abschnitt \hyperref[sec:2.1]{2.1} beschriebenen Format vorliegen. Sollte dabei etwas schief gehen, wird im \lstinline[columns=fixed]{catch}-Block ein Fenster mit einer einfachen Fehlermeldung angezeigt.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{saveFile}]
@Override
public void saveFile(Object object) {
	FileChooser chooser = new FileChooser();
	chooser.setTitle("Save file");
	File selectedFile = chooser.showSaveDialog(new Stage());
	if(selectedFile != null) {
		GrammarUtil.save((Grammar) object, selectedFile.getAbsolutePath());
	}
}
\end{lstlisting}
Genau wie in \lstinline[columns=fixed]{openFile()} wird hier zunächst ein FileChooser angezeigt. Der Pfad zu der ausgewählten Datei wird dann der Methode \lstinline[columns=fixed]{save(Grammar grammar, String path)} aus der Klasse \lstinline[columns=fixed]{GrammarUtil} übergeben, welche die aktuelle Grammatik in diese Datei schreibt. Dabei wird das in Abschnitt \hyperref[sec:2.1]{2.1} beschriebene Format verwendet.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{menus}]
@Override
public HashSet<Menu> menus(Object object, Node node) {
	MenuItem helpItem = new MenuItem("Help");
	MenuItem aboutItem = new MenuItem("About Plugin");
	
	helpItem.setOnAction(event -> {
		Alert alert = new Alert(Alert.AlertType.INFORMATION);
		alert.setTitle("STUPS-Toolbox");
		alert.setHeaderText("This is just a simple example plugin,\nthat displays all productions of the loaded grammar.");
		alert.showAndWait();
	});
	
	aboutItem.setOnAction(event -> {
		Alert alert = new Alert(Alert.AlertType.INFORMATION);
		alert.setTitle("STUPS-Toolbox");
		alert.setHeaderText("Grammar Example Plugin v1.0");
		alert.showAndWait();
	});
	
	Menu aboutMenu = new Menu("Help");
	aboutMenu.getItems().addAll(helpItem, aboutItem);
	
	return new HashSet<>(Arrays.asList(aboutMenu));
}
\end{lstlisting}
Hier werden zwei \lstinline[columns=fixed]{MenuItem}s erstellt, die einen kurzen Hilfetext, bzw. eine Versionsnummer anzeigen, wenn der Benutzer auf sie klickt. Anschließend werden diese einem \lstinline[columns=fixed]{Menu}-Objekt hinzugefügt und dieses als Teil eines \lstinline[columns=fixed]{HashSet}s zurückgegeben. Das Hauptprogramm fügt alle Objekte in diesem \lstinline[columns=fixed]{HashSet} in die Menüleiste ein, wenn das Plugin ausgewählt wird.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{getName}]
@Override
public String getName() {
	return "Grammar Example";
}
\end{lstlisting}
\lstinline[columns=fixed]{getName()} gibt den Namen des Plugins als String zurück.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{displayType}]
@Override
public Class displayType() {
	return Grammar.class;
}
\end{lstlisting}
Dieses Plugin arbeitet mit Grammatiken, dementsprechend wird hier \lstinline[columns=fixed]{Grammar.class} zurückgegeben.
\paragraph{Das Grammatik-Plugin erweitern mit dem Interface \textit{GrammarTab}}\ \\
Da es noch viele weitere Funktionen gibt, die der Grammatikoberfläche hinzugefügt werden könnten, habe ich mich dazu entschlossen das Plugin \lstinline[columns=fixed]{GrammarGUI} ebenfalls erweiterbar zu gestalten. Hierfür gibt es ein sehr einfaches Interface, welches ein Objekt vom Typ \lstinline[columns=fixed]{Node} erstellt. Dieses wird dann dem \lstinline[columns=fixed]{TabbedPane} von \lstinline[columns=fixed]{GrammarGUI} hinzugefügt. Das Interface \lstinline[columns=fixed]{GrammarTab} liegt im Ordner \textit{GUIPlugins/DisplayPlugins/GrammarTabs} und alle Klassen, die es implementieren, müssen sich ebenfalls in diesem Ordner befinden. Es besteht nur aus den folgenden zwei Methoden:
\begin{itemize}
	\item \lstinline[columns=fixed]{Node getFxNode(Grammar grammar)}:\\
	Diese Methode macht das Gleiche, wie die oben beschriebene Methode \lstinline[columns=fixed]{display(Object object)} aus dem Interface \lstinline[columns=fixed]{DisplayPlugin}, indem sie ein Objekt vom Type \lstinline[columns=fixed]{Node} zurückgibt. Dieses wird in der Oberfläche für Grammatiken in einem eigenen Tab angezeigt.
	\item \lstinline[columns=fixed]{String getName()}:\\
	\lstinline[columns=fixed]{getName()} gibt den Namen des Tabs zurück. Dieser wird in der Oberfläche angezeigt.
\end{itemize}
\paragraph{Das Interface \textit{SimpleFunctionPlugin}}\ \\
Mit dem Interface \lstinline[columns=fixed]{SimpleFunctionPlugin} ist es möglich der grafischen Oberfläche neue Funktionen hinzuzufügen, die ein Objekt (zum Beispiel eine Grammatik) als Eingabe nehmen, und dieses verändern. Das neue Objekt wird dann direkt in der Oberfläche angezeigt. Diese Plugins werden unten rechts in einem Dropdown-Menü angezeigt (wie in Abschnitt \hyperref[sec:2.4.2]{2.4.2} beschrieben). \lstinline[columns=fixed]{SimpleFunctionPlugin} besteht aus den folgenden vier Methoden:
\begin{itemize}
	\item \lstinline[columns=fixed]{Object execute(Object object)}:\\
	Als Parameter wird hier ein Objekt von dem Typ übergeben, mit dem dieses Plugin arbeitet. Der Rückgabewert dieser Methode ist das veränderte Objekt, oder sogar ein Objekt von einem ganz anderem Typ. Dies funktioniert genauso wie beim Interface \lstinline[columns=fixed]{CLIPlugin}.
	\item \lstinline[columns=fixed]{String getName()}:\\
	Der Rückgabewert dieser Methode ist ein String mit dem Namen des Plugins. Dieser wird in dem Dropdown-Menü angezeigt.
	\item \lstinline[columns=fixed]{Class inputType()}:\\
	Diese Methode gibt den Klassentyp des Eingabeobjekts von \lstinline[columns=fixed]{Object execute(Object object)} zurück. Das Plugin wird nur angezeigt, wenn der Rückgabewert von \lstinline[columns=fixed]{inputType()} mit dem Rückgabewert der Methode \lstinline[columns=fixed]{displayType()} des aktuell angezeigten \lstinline[columns=fixed]{DisplayPlugin}s übereinstimmt.
	\item \lstinline[columns=fixed]{Class outputType()}:\\
	Diese Methode gibt den Klassentyp des Rückgabewertes von \lstinline[columns=fixed]{Object execute(Object object)} zurück. Dieser muss nicht gleich dem Eingabetypen sein.
\end{itemize}
\newpage
Diese Methoden werden nun anhand der Klasse \lstinline[columns=fixed]{AutomatonConvertToDFAPlugin} weiter erläutert:
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{execute}]
@Override
public Object execute(Object object) {
	Automaton automaton = (Automaton) object;
	return AutomatonUtil.convertToDFA(automaton);
}
\end{lstlisting}
Das übergebene Objekt wird zunächst per Typecast in einen Automaten umgewandelt. Anschließend wird dieser Automat mit Hilfe der Methode \lstinline[columns=fixed]{convertToDFA(Automaton automaton)} aus der Klasse \lstinline[columns=fixed]{AutomatonUtil} in einen DFA umgewandelt und zurückgegeben.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{getName}]
@Override
public String getName() {
	return "Convert to DFA";
}
\end{lstlisting}
Die Methode gibt einfach nur den Namen des Plugins als String zurück. In dem Dropdown-Menü erscheint nun der Eintrag \textit{Convert to DFA}.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{inputType}]
@Override
public Class inputType() {
	return Automaton.class;
}
\end{lstlisting}
\lstinline[columns=fixed]{Object execute(Object object)} erwartet einen Automaten als Parameter, dementsprechend wird hier \lstinline[columns=fixed]{Automaton.class} zurückgegeben.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{outputType}]
@Override
public Class outputType() {
	return Automaton.class;
}
\end{lstlisting}
Der Rückgabetyp von \lstinline[columns=fixed]{Object execute(Object object)} ist ebenfalls ein Automat, deshalb wird hier auch \lstinline[columns=fixed]{Automaton.class} zurückgegeben.
\paragraph{Das Interface \textit{ComplexFunctionPlugin}}\ \\
Mit dem Interface \lstinline[columns=fixed]{ComplexFunctionPlugin} ist es möglich der grafischen Oberfläche neue Funktionen hinzuzufügen, die ihrerseits eine eigene Oberfläche besitzen. Diese werden, wie in Abschnitt \hyperref[sec:2.4.2]{2.4.2} beschrieben, unten links in der grafischen Oberfläche angezeigt. Des Weiteren bekommen diese Plugins eine Instanz des gerade angezeigten \lstinline[columns=fixed]{DisplayPlugin}s, so dass es mit diesem zusammenarbeiten kann. Dadurch ist es natürlich auch an ein bestimmtes \lstinline[columns=fixed]{DisplayPlugin} gebunden. \lstinline[columns=fixed]{ComplexFunctionPlugin} setzt sich aus den folgenden drei Methoden zusammen:
\begin{itemize}
	\item \lstinline[columns=fixed]{Node getFxNode(Object object, DisplayPlugin Main.GUI)}:\\
	Ähnlich wie bei dem Interface \lstinline[columns=fixed]{GrammarTab} wird hier ein Objekt vom Type \lstinline[columns=fixed]{Node} zurückgegeben, das in der grafischen Oberfläche angezeigt werden soll. Als Parameter werden ein Objekt (zum Beispiel eine Grammatik, oder ein Automat) und ein DisplayPlugin übergeben. So kann diese Methode auf Ressourcen des DisplayPlugins zugreifen. Wie das genau funktionieren kann, wird weiter unten anhand eines Beispiels gezeigt.
	\item \lstinline[columns=fixed]{String getName()}:\\
	Gibt den Namen des Plugins als String zurück. Dieser wird oberhalb des in \lstinline[columns=fixed]{getFxNode(Object object, DisplayPlugin Main.GUI)} zurückgegeben \lstinline[columns=fixed]{Node}s in einem \lstinline[columns=fixed]{Label} angezeigt.
	\item \lstinline[columns=fixed]{Class displayPluginType()}:\\
	Hier wird der Klassentyp des \lstinline[columns=fixed]{DisplayPlugin}s, welches \lstinline[columns=fixed]{getFxNode(Object object, DisplayPlugin Main.GUI)} als zweiter Parameter übergeben wird zurückgegeben. Dieses Plugin wird nur angezeigt, wenn das aktuell angezeigte \lstinline[columns=fixed]{DisplayPlugin} den hier zurückgegeben Typen hat.
\end{itemize}
Wie die Zusammenarbeit zwischen einem \lstinline[columns=fixed]{ComplexFunctionPlugin} und einem \lstinline[columns=fixed]{DisplayPlugin} laufen könnte, wird nun durch ein kurzes Beispiel-Plugin gezeigt, mit welchem der Benutzer ein anderes Layout für den Übergangsgraphen wählen kann:
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{getFxNode}]
@Override
public Node getFxNode(Object object, DisplayPlugin Main.GUI) {
	AutomatonGUI automatonGUI = (AutomatonGUI) Main.GUI;
	VisualizationViewer<String, Integer> viewer = automatonGUI.getVisualizationViewer();
	Graph<String, Integer> graph = automatonGUI.getGraph();
	
	MenuBar menuBar = new MenuBar();
	Menu layoutMenu = new Menu("Choose Layout");
	
	MenuItem circleLayout = new MenuItem("Circle Layout");
	MenuItem frLayout = new MenuItem("FR Layout 1");
	MenuItem frLayout2 = new MenuItem("FR Layout 2");
	MenuItem isomLayout = new MenuItem("ISOM Layout");
	MenuItem kkLayout = new MenuItem("KK Layout");
	
	circleLayout.setOnAction(event -> viewer.setGraphLayout(new CircleLayout<>(graph)));
	frLayout.setOnAction(event -> viewer.setGraphLayout(new FRLayout<>(graph)));
	frLayout2.setOnAction(event -> viewer.setGraphLayout(new FRLayout2<>(graph)));
	isomLayout.setOnAction(event -> viewer.setGraphLayout(new ISOMLayout<>(graph)));
	kkLayout.setOnAction(event -> viewer.setGraphLayout(new KKLayout<>(graph)));
	
	layoutMenu.getItems().addAll(circleLayout, frLayout, frLayout2, isomLayout, kkLayout);
	menuBar.getMenus().add(layoutMenu);
	
	return menuBar;
}
\end{lstlisting}
Im ersten Schritt wird das übergebene \lstinline[columns=fixed]{DisplayPlugin} in eine Instanz von \lstinline[columns=fixed]{AutomatonGUI} umgewandelt und die benötigten Ressourcen daraus geholt. Diese sind der \lstinline[columns=fixed]{VisualizationViewer} und der \lstinline[columns=fixed]{Graph}. Anschließend wird ein Menü mit fünf Einträgen für die verschiedenen Layouts initialisiert. Die \lstinline[columns=fixed]{setOnAction(EventHandler<ActionEvent> value)}-Methode jedes Menüeintrags ändert das Layout des \lstinline[columns=fixed]{VisualizationViewer}s zu einem bestimmten Layout. Zuletzt werden die Menüeinträge dem Menü hinzugefügt, das Menü in eine \lstinline[columns=fixed]{MenuBar} gepackt und diese zuürckgegeben.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{getName}]
@Override
public String getName() {
	return "Layout Example";
}
\end{lstlisting}
Hier wird der Anzeigename des Plugins festgelegt.
\begin{lstlisting}[frame=single, basicstyle=\small, caption=Die Methode \textit{displayPluginType}]
@Override
public Class displayPluginType() {
	return AutomatonGUI.class;
}
\end{lstlisting}
Dieses Plugin soll nur angezeigt werden, wenn das \lstinline[columns=fixed]{DisplayPLugin} \lstinline[columns=fixed]{AutomatonGUI} angezeigt wird. Dementsprechend wird hier \lstinline[columns=fixed]{AutomatonGUI.class} zurückgegeben.
\paragraph{Optionalität der Plugins}\ \\
Die Benutzung der Interfaces \lstinline[columns=fixed]{SimpleFunctionPlugin} und \lstinline[columns=fixed]{ComplexFunctionPlugin} ist bei der Entwicklung neuer grafischer Oberflächen optional. Es ist auch möglich, alle Funktionen direkt in das \lstinline[columns=fixed]{DisplayPlugin} einzubauen. Jedoch bieten die beiden Interfaces eine einfache Möglichkeit neue Oberflächen übersichtlich und modular zu programmieren.
\subsection{Die Toolbox um neue Datentypen erweitern}
\label{sec:3.4}
Neue Datentypen zum Programm hinzuzufügen ist sehr einfach. Die Klasse \lstinline[columns=fixed]{Main.CLI} hat ein \lstinline[columns=fixed]{HashSet} von Objekten. Wenn ein Plugin ein Objekt von einem Datentyp zurückgibt, der noch nicht in diesem \lstinline[columns=fixed]{HashSet} vorkommt, wird es ihm hinzugefügt. Falls es bereits ein Objekt diesen Datentyps gibt, wird dieser Eintrag im \lstinline[columns=fixed]{HashSet} durch das neue Objekt ersetzt. Das Ganze funktioniert völlig unabhängig davon, welchen Datentyp ein Objekt hat.\\
Um nun einen neuen Datentyp hinzuzufügen, muss man nur irgendwo im Programm eine Klasse erstellen, die den neuen Datentypen repräsentiert. Sobald es ein Plugin gibt, das ein Objekt von diesesm Datentyp zurückgibt, ist dieser im Programm.