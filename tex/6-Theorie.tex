%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Theoretische Aspekte}\raggedbottom \label{sec:theorie}
Beim Umsetzen der Algorithmen in echten Code kam es zu einigen Schwierigkeiten,
da die Algorithmen aus didaktischen Gründen so geschrieben sind, dass sie für
Menschen leicht umsetzbar sind, jedoch nicht so einfach für Computer. Ein
prägnantes Beispiel hierfür ist:\\
Finde alle Kreise und entferne sie.\\
Für einen Menschen sind die Kreise in einem Graphen leicht ersichtlich, ein
Computer muss erst eine Breitensuche laufen lassen und Rückwärtskanten
ermitteln.

Alle Beispiele wurden durch die Toolbox generiert und mit leichten Modifizierungen
übernommen. Die jetzt als Paragraphen erscheinden Überschriften sind 
eigentlich \textit{Sections}, jedoch wären sie dann im Inhaltsverzeichnis dieser Arbeit
aufgetaucht.

Die Algorithmen sind, wenn nicht anders angegeben, dem Skript \cite{Rot16} zur Vorlesung \textit{Einführung in die theoretische Informatik} an der Heinrich-Heine-Universität entnommen.

Da angedacht ist, die Toolbox in der Lehre zu verwenden,
wurde darauf geachtet, die tatsächlich Umsetzung dicht an den Algorithmen im
Skript zu belassen und die Durchführung nachvollziehbar zu gestalten.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kellerautomaten}

\subsubsection{Einen String überprüfen} % todo eher woanders hin?
Durch das \textit{ComplexFunctionPlugin CheckStringPDAPlugin} ist es möglich, zu überprüfen, ob ein PDA ein Wort akzeptiert. Hierfür wurden die Produktionsregeln in der GUI als Buttons dargestellt. Nach Start des Plugins
ist es möglich, mit diesen Buttons einen Durchlauf zu simulieren.
Es sind immer nur die Regeln auswählbar, die auch mit dem aktuellen Input und dem \textit{Top of Stack}
kompatibel sind.
Intern wurde der Durchlauf durch eine weitere Klasse \textit{RunThroughInfo} ermöglicht. Diese ist eine Konfiguration
eines Durchlaufs.
Der PushDownAutomat hat als einzige veränderbare Variable den aktuellen Zustand in dem er sich befindet.
In der \textit{RunThroughInfo} wird der Stack, der einzulesende Input, der aktuelle Zustand und die vorherige  \textit{RunThroughInfo} gespeichert. %todo
Wird eine Regel vom Nutzer ausgewählt, wird diese auf die aktuelle \textit{RunThroughInfo} angewandt und dadurch entsteht eine neue Konfiguration, welche die alte Konfiguration als Vorgänger hat.

\subsubsection{Umwandeln in Grammatik}
Es ist möglich, einen Kellerautomaten in eine äquivalente Grammatik umzuformen und umgekehrt (\ref{grammar2pda}).
Dafür muss der Kellerautomat zunächst in einen äquivalenten Kellerautomaten, der nur 
Regeln der Form $z_i a_i A_i \rightarrow z_j B_{i_1} B_ {i_2} $ hat, umgewandelt werden.
Eine Möglichkeit, dies zu tun, ist in Algorithmus \ref{alg:2tos} angegeben. 


\begin{algorithm}[htbp]
\caption{Umwandeln}
\label{alg:2tos}
\begin{algorithmic} 
\REQUIRE PDA P mit Regeln $zaA \rightarrow z'B_1B_2 \ldots B_k$ mit $k > 2$ 
\ENSURE PDA ohne Regeln $zaA \rightarrow z'B_1B_2 \ldots B_k$ mit $k > 2$
\FORALL{Regel $zaA \rightarrow z'B_1B_2 \ldots B_k$ mit $k > 2$} 
	\STATE Wähle neue Zustände $z_1, z_2, \ldots z_{k-2}$ 
	\STATE Ersetze diese Regel durch die folgenden neuen $\delta$-Regeln:
	\begin{align*}
z a A &\rightarrow z_1 B_{k-1}B_k \\
z_1 \lambda B_{k-1} &\rightarrow  z_2 B_{k-2}B_{k-1} \\
&\vdots \\
z_{k-2} \lambda B_2 &\rightarrow z' B_1 B_2
\end{align*}	
\ENDFOR 
\RETURN P
\end{algorithmic}
\end{algorithm}

Nun kann Algorithmus \ref{alg:pda2grammar} angewandt werden.
Hierbei ist zu beachten, dass $z'$ und $z''$ \textbf{beliebige} Zustände aus $Z$ sind, d.h. es müssen
alle möglichen Kombinationen durchlaufen werden.
Es sei außerdem erwähnt, dass bei dem Algorithmus Nichtterminale entstehen, die nie erreicht werden. Das geht aus 
dem Algorithmus nicht klar hervor.
Die Toolbox entfernt diese Zustände nach Durchführung.

Des Weiteren sei bemerkt, dass die im Algorithmus \ref{alg:pda2grammar} verwendeten Klammern in den Nichtterminalen
weggelassen worden sind, da der Parser diese nicht in Nichtterminalen erlaubt.
In Terminalen sind Sonderzeichen wie +,-,\&,\#,\ldots erlaubt, in Nichtterminalen allerdings nicht. Da der Algorithmus aber aus Terminalen Nichtterminale
macht, mussten diese Sonderzeichen eliminiert werden. Dies geschieht, indem jeder einzelne Char eines Nichtterminales überprüft wird,
und wenn dieser nicht erlaubt ist, wird er zu einem Integer gecastet. Zahlen in Nichtterminalen sind erlaubt. Anstatt des nicht erlaubten Chars wird dann dieser korrespondierende Integerwert geschrieben.

Der Beweis der Äquivalenz wird hier nicht erneut geführt, da er sich bereits in \cite[S.75-77]{Rot16} befindet.
\begin{algorithm}[htbp]
\label{alg:pda2grammar}
\caption{PDA zu Grammatik}         
                    
\begin{algorithmic}    
\REQUIRE PDA $M=(\Sigma, \Gamma, Z, \delta, z_0, \#)$ mit $k \leq 2$ für alle Regeln $zaA \rightarrow z'B_1B_2 \ldots B_k$
\ENSURE Eine äquivalente Grammatik $G= (\Sigma, \{ S \} \cup Z \times \Gamma \times Z, S, P)$
\STATE  $G= (\Sigma, \{ S \} \cup Z \times \Gamma \times Z, S, P)$
\STATE P besteht dabei aus folgenden Regeln
\begin{align*}
1. &S \rightarrow (z_0, \#, z) \textrm{ für jedes } z \in Z\\
2. &(z, A, z') \rightarrow a, \textrm{ falls } (z',\lambda) \in \delta (z,a,A) \\
3. &(z, A, z') \rightarrow a(z_1,B,z'),\textrm{ falls } (z_1,B) \in \delta (z,a,A) \\
4. &(z, A, z') \rightarrow a(z_1,B,z'')(z'',C,z'), \textrm{ falls } (z_1,BC) \in \delta (z,a,A)
\end{align*}
Hierbei sind $z,z_1 \in Z, A,B,C \in \Gamma, a \in \Sigma \cup \{\lambda \}$ und $z', z'' \in Z$ beliebig.
\RETURN G
\end{algorithmic}
\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Algorithmen für Grammatiken}

\subsubsection{Entfernen von $\lambda$-Regeln}
Zu jeder Grammatik mit Lambda-Regeln gibt es eine Grammatik ohne $\lambda$-Regeln,
die die selbe Sprache erzeugt. Hierbei akzeptieren wir Regeln $S \rightarrow
\lambda$, damit $\lambda \in L(G)$ möglich ist.
\begin{enumerate}
  \item Bestimme zuerste die Menge aller Nichtterminale, die auf das leere Wort
  abgeleitet werden können
  \[ N_{\lambda} = \{A \in N \mid A \vdash_G^* \lambda\} \]
  \item Füge für jede Regel der Form
\[ B \rightarrow uAv \textrm{ mit } B \in N, A \in N_{\lambda} \textrm{ und } uv
\in {(N \cup \lambda)}^{+}\] 
zusätzlich die Regel $B \rightarrow uv$ zu P hinzu.
  \item Entferne alle Regeln $A \rightarrow \lambda$ aus P.
\end{enumerate}
Regel 2 muss dabei auch für alle neu entstanden Regeln angewandt werden.

Dies wurde im Hintergrund mit einer Queue\footnote{Link zur Javadoc Queue}
umgesetzt. Zuerst werden alle Regeln, die ein Symbol, welches sich auf das leere
Wort ableiten lässt (im Folgenden \textit{Nullsymbol} genannt), zu der Queue
hinzugefügt.
Nun wird immer eine Regel vom Anfang der Queue entfernt und ein Nullsymbol
gelöscht, so dass eine Regel entsteht, die noch nicht betrachtet wurde. Die neue
Regel wird am Ende der Queue eingefügt. Zusätzlich wird auch die ursprüngliche
Regel wieder hinzugefügt, falls sie weitere Nullsymbole enthält.
Sobald keine Änderungen mehr auftreten bzw. die Queue leer ist, %todo, was
% denn nun?`
stoppt der Algorithmus.
\paragraph{Beispiel}
\input{Beispiele/RLR-Example}

\subsubsection{Entfernen von einfachen Regeln}
Zu jeder Grammatik mit einfachen Regeln (unit Rules, $A \rightarrow B$ mit
$A,B \in N$) gibt es eine Grammatik ohne einfache Regeln, die die selbe Sprache
erzeugt.
\begin{enumerate}
  \item Entferne alle Zyklen und ersetze die Nichtterminale eines Zykels durch
  dasselbe Symbol
  \item Nummeriere die Nichtterminale so, dass aus $A_i \rightarrow A_j$ $i<j$
  folgt
  \item Für $k=n-1,n-2,\ldots,1$ (rückwärts) eliminiere die Regel $A_k
  \rightarrow A_l$ mit $l<k$ so:\\
  Füge jede Regel, die $A_l$ als linke Seite hat, als neue Regel mit $A_k$ als
  linke Seite zu $P$ hinzu.
\end{enumerate}

Das Finden der Zykel wurdn durch eine Tiefensuche implementiert.
Die einfachen Regeln werden als gerichteter Graph betrachtet. Jedes
Nichtterminal ist Knoten, eine Kante zwischen zwei Knoten $A$ und $B$ besteht
genau dann, wenn die Grammatik die Regel $A \rightarrow B$ enthält.

Nach dem Durchführen der Tiefensuche können Rückwärtskanten identifiziert
werden.
Nun wird eine Rückwärtskante entfernt, indem die beiden Knoten zu einem Knoten
verschmelzen und es wird erneut eine Tiefensuche durchgeführt.
Dies wird solange gemacht, bis es keine Rückwärtskanten mehr gibt. Dann gibt es
auch keine Zykel mehr. 
\paragraph{Beispiel}
\input{Beispiele/EUR-Example}

\subsubsection{Chomsky-Normal-Form}
Eine Grammatik ist in Chomsky-Normalform, falls jede Regeln eine der folgenden
Formen hat
\begin{itemize}
  \item $A \rightarrow BC$ mit $A,B,C \in N$
  \item $A \rightarrow a$ mit $A \in N, a \in \Sigma$
\end{itemize}
Zu jeder Grammatik gibt es eine äquivalente Grammatik in Chomsky-Normal-Form.
\begin{enumerate}
  \item Regeln $A \rightarrow a$ mit $A \in N$ und $a \in \Sigma$ sind in CNF
  und werden übernommen. Alle anderen Regeln sind von der Form: $A \rightarrow x$ mit $x \in (N
  \cup \Sigma)^{*}$ und $\mid x \mid \geq 2$.
  \item  Füge für jedes $a \in \Sigma$ ein neues Nichtterminal $X_a$ zu $N$
  hinzu, ersetze jedes Vorkommen von $a \in \Sigma$ durch $X_a$ und füge zu P die
  Regel $X_a \rightarrow a$ hinzu.
  \item Nicht in CNF sind nun nur noch Regeln der Form
	\[A \rightarrow B_1B_2 \ldots B_k,\] 
	wobei $k \geq 3$ und jedes $B_i$ ein Nichtterminal ist:
	Jede solche Regel wird ersetzt durch die Regeln:
	\begin{align*}
	A &\rightarrow B_1C_2 \\
	C2 &\rightarrow B_2C_3 \\
	&\ldots \\
	C_{k-2} &\rightarrow B_{k-2}C_{k-1} \\
	C_{k-1} &\rightarrow B_{k-1}B_k
	\end{align*}
	wobei $C_2,C_3,\ldots,C_{k-1}$ neue Nichtterminale sind.
\end{enumerate}
Bemerke, dass auch hier wieder im zweiten Schritt ungültige Nichtterminalsymbole entstehen können. Sollte dies passieren, wird 
stattdessen ein unbesetzter Großbuchstabe als Nichtterminal gewählt.
\paragraph{Beispiel}
\input{Beispiele/CNF-Example}

\subsubsection{CYK}
Der Cocke-Younger-Kasami-Algorithmus (CYK) löst das Wortproblem für kontextfreie
Sprachen in kubischer Zeit. 
%todo Quelle

\begin{algorithm}[H]
\caption{CYK}          % give the algorithm a caption
\label{alg:cyk}                           % and a label for \ref{} commands later in the document
\begin{algorithmic}
\REQUIRE $G = (\Sigma, N, S, P)$ kfG in CNF, $ x = a_1 a_2 \ldots a_n \in \Sigma^{*}$ 
\ENSURE eine Tabelle $T$, deren Zellen Mengen von Nichtterminalen sind.
\FOR{$i=1$ \TO $n$} 
	\STATE $T(i,0)=\{A \in N \mid A \rightarrow a_i \textrm{ ist Regel in P}\}$
\ENDFOR
\FOR{ $j=1$ \TO $n-1$}
	\FOR{$i = 1$ \TO $n-j$}
		\STATE $T(i,j)= \emptyset$
		\FOR{$k = 0$ \TO $j-1$}
			 \STATE $T(i,j)=T(i,j) \cup \{A \in N \mid \textrm{ es gibt eine Regel } A \rightarrow BC \textrm{ in P} \textrm{ und } B \in T(i,k) \textrm{ und } C \in T(i+k+1,j-k-1)\}$
		\ENDFOR
	\ENDFOR
\ENDFOR
\RETURN $T$
\end{algorithmic}
\end{algorithm}
Dieser Algorithmus wurde genau so in der Klasse \textit{GrammarUtils} umgesetzt.
Dafür wurde eine neue Klasse \textit{Matrix} geschrieben, die eben diese Tabelle
\textit{T} darstellt.
\paragraph{Beispiel}
\input{Beispiele/CYK}

\subsubsection{Wortproblem}
Mittels des CYK-Algorithmus lässt sich für eine kontextfreie Grammatik
bestimmen, ob ein Wort in der Sprache ist. Dazu wird die Grammatik in Chomsky-Normal-Form
umgewandelt und anschließend der CYK durchgeführt. Steht das Startsymbol in der
linken oberen Zelle, so ist das Wort in der Sprache.

\subsubsection{Finde einen Pfad}
Das Finden einen Ableitungspfads eines bestimmten Wort ist kein einfach zu
lösendes Problem. Quelle/Zitat/Wortproblem.

Es wurde die Möglichkeit implementiert, unter bestimmten Umständen einen Pfad zu
finden. Zum Einen liefert der CYK-Algorithmus indirekt einen Pfad, indem man
zurückverfolgt, warum das Startsymbol in der oberen linken Ecke steht.
Zum Anderen wurde eine Breitensuche implementiert. Eine Regel ist das Kind einer 
anderen Regel, wenn sie durch Ableiten des ersten Nichtterminals entsteht. Durch
die Breitensuche wird gewährleistet, dass man nicht in einem unendlichen Pfad
landet, der nie auf der gesucht Wort führt. Die Breitensuche wird nur
durchgeführt, wenn vorher mit dem CYK gewährleistet werden konnte,
dass das Wort in der Sprache ist und somit tatsächlich ein Pfad
existiert. 

Allerdings dauert die Breitensuche bei komplizierten Grammatiken zu
lange. Daher wurde eine obere Grenze eingeführt, die der Benutzer selber
bestimmt. Sobald diese Anzahl an Regeln betracht wurde, bricht der Algorithmus ab und liefert kein Ergebnis.
\paragraph{Beispiel}
\input{Beispiele/FindPathExample}

\subsubsection{Sonderregel für das leere Wort}
Da verkürzende Regeln nicht erlaubt sind, ist $\lambda \not\in L(G)$. Dies ist
jedoch nicht immer wünschenswert, daher ist die  Regel $S \rightarrow
\lambda$ erlaubt, jedoch darf $S$ dann auf keiner rechten Seite einer Regel
vorkommen.
Im Skript wurde nur der Fall erklärt, wie man $\lambda \in L(G)$ erreicht, ohne
die oben beschriebene Bedingung zu verletzen. 
Im Algorithmus für das Entfernen von Lambda-Regeln stand jedoch, dass man die
Sonderregel anwenden soll, wenn $\lambda \in L(G)$ gilt. Dies erscheint
widersprüchlich. Daher wurde der Algorithmus leicht modifiziert und wird
\textbf{vor} dem Entfernen der Lambda-Regeln durchgeführt, falls $\lambda \in
L(G)$ gilt.
\begin{enumerate}
  \item Füge ein neues Nichtterminalsymbol $S_0$ hinzu
  \item Ersetze jedes Vorkommen von $S$ in einer rechten Seite einer Regel durch
  $S_0$.
  \item Füge Regel von $S$ zu $S_0$ hinzu
\end{enumerate}
Nun kann der Algorithmus zum Entfernen von Lambda-Regeln problemlos und korrekt
durchgeführt werden.
\paragraph{Beispiel}
\input{Beispiele/SpecialRule}
\paragraph{Umwandeln zu PDA}\label{grammar2pda}
Eine kontextfreie Grammatik kann anhand des Algorithmus \ref{alg:grammar2pda} zu einem äquivalenten Kellerautomaten umgeformt werden. 
\begin{algorithm}[H]
\caption{Grammatik in PDA umwandeln}
\label{alg:grammar2pda}
\begin{algorithmic}    
\REQUIRE kontextfreie Grammatik $G = (\Sigma, N, S, P)$
\ENSURE Kellerautomat $M=(\Sigma, N \cup \Sigma, \{z\}, \delta, z, S)$
\STATE Definiere $\delta$ wie folgt:
\begin{itemize}
\item Ist $A \rightarrow q$ eine Regel in $P$ mit $A \in N$ und $q \in (N \cup \Sigma)^{*}$, so sei $(z,q) \in \delta (z, \lambda, A)$.
\item Für jedes $a \in \Sigma$ sei $(z,\lambda) \in \delta (z,a,a)$
\end{itemize}
\RETURN M
\end{algorithmic}    
\end{algorithm}