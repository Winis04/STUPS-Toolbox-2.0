package Print;

import GrammarSimulator.*;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

/**
 * Created by Isabel on 18.11.2016.
 */
public class Printer {
    /**
     * the print mode
     */
    public static PrintMode printmode=PrintMode.CONSOLE;
    /**
     * the current file that should be used
     */
    public static String currentFile;
    //BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));

    public static int deepnes=0;
    public static BufferedWriter writer=null;
    /**
     * Prints a given grammar depending on {@Link printmode}
     *
     * @param grammar The grammar.
     */
    public static void printGrammar(Grammar grammar) {
        grammar.print();
    }

    public static void print(ArrayList<Printable> printables, String[] texts, String titel) {
        switch(printmode) {
            case NO:
                break;
            case CONSOLE:
                printConsole(printables,texts,titel);
                break;
            case LATEX:
                printLatex(printables,texts,titel);
                break;
        }
    }

    public static void printCYKTable(Matrix matrix) {
        switch(printmode) {
            case NO:
                break;
            case LATEX:
                printCYKTableLatex(matrix);
                break;
            case CONSOLE:
                printCYKTableConsole(matrix);
                break;
        }
    }
    public static void printCYkTable(Grammar g, String word, Matrix matrix) {
        switch(printmode) {
            case NO:
                break;
            case LATEX:
                printCYKTableLatex(matrix);
                break;
            case CONSOLE:
                printCYKTableConsole(matrix);
                break;
        }
    }



    private static void printCYKTableLatex(Matrix matrix) {
        try {
            writer.write("\\begin{table}[h!]\n");
            writer.write("\t\\centering\n");
            writer.write("\t\\caption{CYK}\n");
            String s="|";
            for(int i = 0; i<matrix.getNumberOfColumns()-1; i++) {
                s+="c|";
            }
            writer.write("\t\\begin{tabular}{"+s+"}\n");
            //1 & 2 & 3\\
            //\hline
            writer.write("\t\t\\hline\n");
           for(int r=matrix.getNumberOfRows()-1;r>=0;r--) {
               writer.write("\t\t");
               for(int c=1;c<matrix.getNumberOfColumns();c++) {
                   writer.write(matrix.getCell(c,r).stream().map(nonterminal -> "$"+nonterminal.getName()+"$").collect(joining(", ")));
                   if(c<matrix.getNumberOfColumns()-1) {
                       writer.write(" & ");
                   }
               }


               writer.write("\\\\\n\t\t\\hline\n");
           }
            writer.write("\t\\end{tabular}\n");
            writer.write("\\end{table}\n\n");
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
    public static void printStartOfLatex(BufferedWriter writer) {
        try {
            writer.write("%%this document was generated by the STUPS Toolbox 2.0\n");
            writer.write("\\documentclass{article}\n\\" +
                    "usepackage{amssymb}\n\\" +
                    "usepackage{amsmath,amsthm}\n\\" +
                    "usepackage[ngerman,english]{babel}\n\n\\" +
                    "begin{document}\n\n");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static void printEndOfLatex(BufferedWriter writer) {
        try {
            writer.write("\\end{document}");
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static String makeToGreek(String string) {
        if(string.equals("epsilon")||string.equals("lambda")) {
            return "\\"+string;
        } else {
            return string;
        }
    }

    private static void printLatex(ArrayList<Printable> printables, String[] texts, String titel) {
        if(printables.size()!=texts.length) {
            return;
        }
        try {
            writer.write("\\section{"+titel+"}\n");
            writer.write("\\begin{description}\n");
            Printer.deepnes++;
            for(int i=0;i<printables.size();i++) {
                writeItem("Step "+i,texts[i]);
                printables.get(i).print();
            }
            Printer.deepnes--;
            writer.write("\\end{description}\n");

        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    private static void printConsole(ArrayList<Printable> printables, String[] texts, String titel) {
        if(printables.size()!=texts.length) {
            return;
        }
        BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(System.out));
        try {
            for(int i=0;i<printables.size();i++) {
                writer.write("Step "+i+": "+texts[i]+"\n");
                writer.flush();
                printables.get(i).print();
                writer.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
    private static void writeItem(String titel, String subtitel) throws IOException {
        String s="";
        for(int i=0;i<Printer.deepnes;i++) {
            s+="\t";
        }
        writer.write(s+"\\item["+titel+"] "+subtitel +"\n");
    }




    /** CONSOLE **/
    private static void printCYKTableConsole(Matrix matrix) {

    }






    /** HELP METHODS **/

    public static ArrayList<String>[] getHeader(Grammar grammar) {
        ArrayList<String>[] header=new ArrayList[3];
        header[0]=getTerminalsAsStrings(grammar);
        header[1]=getNonterminalsAsStrings(grammar);
        ArrayList<String> tmp=new ArrayList<>();
        tmp.add(grammar.getStartSymbol().getName());
        header[2]=tmp;
        return header;
    }


    private static ArrayList<String> getTerminalsAsStrings(Grammar grammar) {
        //Get all of the grammar's terminals in order of their appearance in the rules.
        ArrayList<Terminal> terminals = GrammarUtil.getTerminalsInOrder(grammar);
        return (ArrayList<String>) terminals.stream().map(terminal -> terminal.getName()).collect(Collectors.toList());
    }

    private static ArrayList<String> getNonterminalsAsStrings(Grammar grammar) {
        ArrayList<Nonterminal> nonterminals = GrammarUtil.getNonterminalsInOrder(grammar);
        return (ArrayList<String>) nonterminals.stream().map(nonterminal -> nonterminal.getName()).collect(Collectors.toList());
    }
    private static HashSet<ArrayList<String>> getRulesToNonterminal(Grammar grammar, Nonterminal nonterminal) {
        HashSet<ArrayList<Symbol>> lists=nonterminal.getSymbolLists();
        HashSet<ArrayList<String>> result=new HashSet<>();
        for(ArrayList<Symbol> list : lists) {
            result.add((ArrayList<String>)list.stream().map(symbol -> symbol.getName()).collect(toList()));
        }
        return result;
    }

}
