package Print;

import GrammarSimulator.*;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

/**
 * Created by Isabel on 18.11.2016.
 */
public class Printer {
    /**
     * the print mode
     */
    public static PrintMode printmode=PrintMode.CONSOLE;
    /**
     * the current file that should be used
     */
    public static String currentFile;
    //BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));

    public static int deepnes=0;
    public static BufferedWriter writer=null;
    /**
     * Prints a given grammar depending on {@Link printmode}
     *
     * @param grammar The grammar.
     */
    public static void printGrammar(Grammar grammar) {
        switch(printmode) {
            case NO:
                break;
            case LATEX:
                printGrammarLatex(grammar,0);
                break;
            case CONSOLE:
                printGrammarConsole(grammar);
                break;
        }


    }

    public static void printCNF(Grammar grammar) {
        switch(printmode) {
            case NO:
                GrammarUtil.chomskyNormalForm(grammar);
                break;
            case LATEX:
                printCNFLatex(grammar);
                break;
            case CONSOLE:
                printCNFConsole(grammar);
                break;
        }
    }


    public static void printEliminateUnitRules(Grammar grammar) {
        switch(printmode) {
            case NO:
                GrammarUtil.eliminateUnitRules(grammar);
                break;
            case LATEX:
                printEliminateUnitRulesLatex(grammar);
                break;
            case CONSOLE:
                printEliminateUnitRulesConsole(grammar);
                break;
        }
    }

    public static void printRemoveLambdaRules(Grammar grammar) {
        switch(printmode) {
            case NO:
                GrammarUtil.removeLambdaRules(grammar);
                break;
            case LATEX:
                printRemoveLambdaRulesLatex(grammar);
                break;
            case CONSOLE:
                printRemoveLambdaRulesConsole(grammar);
                break;
        }
    }
    public static void printCYKTable(Matrix matrix) {
        switch(printmode) {
            case NO:
                break;
            case LATEX:
                printCYKTableLatex(matrix);
                break;
            case CONSOLE:
                printCYKTableConsole(matrix);
                break;
        }
    }
    public static void printCYkTable(Grammar g, String word, Matrix matrix) {
        switch(printmode) {
            case NO:
                break;
            case LATEX:
                printCYKTableLatex(matrix);
                break;
            case CONSOLE:
                printCYKTableConsole(matrix);
                break;
        }
    }





    /** PRIVATE METHODS **/

    /** LATEX **/

    private static void printCYKTableLatex(Matrix matrix) {
        try {
            writer.write("\\begin{table}[h!]\n");
            writer.write("\t\\centering\n");
            writer.write("\t\\caption{CYK}\n");
            String s="|";
            for(int i = 0; i<matrix.getNumberOfColumns()-1; i++) {
                s+="c|";
            }
            writer.write("\t\\begin{tabular}{"+s+"}\n");
            //1 & 2 & 3\\
            //\hline
            writer.write("\t\t\\hline\n");
           for(int r=matrix.getNumberOfRows()-1;r>=0;r--) {
               writer.write("\t\t");
               for(int c=1;c<matrix.getNumberOfColumns();c++) {
                   writer.write(matrix.getCell(c,r).stream().map(nonterminal -> "$"+nonterminal.getName()+"$").collect(joining(", ")));
                   if(c<matrix.getNumberOfColumns()-1) {
                       writer.write(" & ");
                   }
               }


               writer.write("\\\\\n\t\t\\hline\n");
           }
            writer.write("\t\\end{tabular}\n");
            writer.write("\\end{table}\n\n");
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
    public static void printStartOfLatex(BufferedWriter writer) {
        try {
            writer.write("%%this document was generated by the STUPS Toolbox 2.0\n");
            writer.write("\\documentclass{article}\n\\usepackage{amssymb}\n\\usepackage{amsmath,amsthm}\n\\usepackage[ngerman,english]{babel}\n\n\\begin{document}\n\n");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static void printEndOfLatex(BufferedWriter writer) {
        try {
            writer.write("\\end{document}");
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static String makeToGreek(String string) {
        if(string.equals("epsilon")||string.equals("lambda")) {
            return "\\"+string;
        } else {
            return string;
        }
    }

    public static void print(ArrayList<Printable> printables, ArrayList<String> texts, String titel) {
        if(printables.size()!=texts.size()) {
            return;
        } else {
            int n=printables.size();
        }
        try {
            writer.write("\\section{"+titel+"}\n");
            writer.write("\\begin{description}\n");
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    private static void printCNFLatex(Grammar grammar) {
        try {
            writer.write("\\section{Chomsky - Normal - Form}\n");
            writer.write("\\begin{description}\n");
            writer.write("\t\\item[Before]\n");

            printGrammar(grammar,1);
            grammar.modifyName();
            writer.write("\t\\item[Step 1] rules in form of $A \\rightarrow a$ are already in chomsky normal form and we keep them.\n");

            writer.write("\t\\item[Step 2] in all other rules replace every appearance of Terminal a through a new Nonterminal $X_a$ and add the rule $X_a \\rightarrow a$.\n");


            GrammarUtil.chomskyNormalForm_StepOne(grammar);
            printGrammar(grammar,1);
            grammar.modifyName();
            writer.write("\t\\item[Step 3] in all rules that contain more than two nonterminals, add a new nonterminal that points to the end of the rule.\n");

            GrammarUtil.chomskyNormalForm_StepTwo(grammar);
            printGrammar(grammar,1);
            grammar.clearName();

            writer.write("\\end{description}\n");
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    private static void printEliminateUnitRulesLatex(Grammar grammar) {
        try {
            writer.write("\\section{Eliminate unit rules}\n");
            writer.write("\\begin{description}\n");
            writer.write("\t\\item[Before] \n");
            Printer.printGrammar(grammar,1);
            grammar.modifyName();
            HashSet<Node> unitRules=GrammarUtil.removeCircleRules(grammar);
            writer.write("\t\\item[Step 1] remove circles: \\\\ \n");

            Printer.printGrammar(grammar,1);
            grammar.modifyName();
            writer.write("\t\\item[Step 2] number the nonterminals:\n");

            ArrayList<Node> list=GrammarUtil.removeUnitRules(unitRules,grammar);
            writer.write("\t\\begin{align*}\n");

            writer.write(list.stream().map(node -> "\t\t"+node.getName()+ "&: "+ node.getNumber()).collect(joining("\\\\\n")));

            writer.write("\n\t\\end{align*}\n");

            writer.write("\t\\item[Step 3] remove unit rules beginning by the highest number: \\\\ \n");

            Printer.printGrammar(grammar,1);
            grammar.clearName();
            writer.write("\\end{description}\n");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void printRemoveLambdaRulesLatex(Grammar grammar) {
        try {
            writer.write("\\section{Remove lambda-rules}\n");
            writer.write("\\begin{description}\n");
            writer.write("\t\\item[Before] \\hfill \\\\ \n");
            Printer.printGrammar(grammar,1);
            grammar.modifyName();
            if(GrammarUtil.specialRuleForEmptyWord(grammar)) {
                writer.write("\t\\item[Step 0] add new Symbol $S#ยง: \\\\ \n");
                Printer.printGrammar(grammar,1);
                grammar.modifyName();
            }
            //first step: calculate the Nullable set
            HashSet<Nonterminal> nullable= GrammarUtil.calculateNullable(grammar);
            writer.write("\t\\item[Step 1] nullable = \\{"+ nullable.stream().map(nt -> nt.getName()).collect(Collectors.joining(", "))+"\\}\n");
            writer.write("\t\\item[Step 2]\n");
            //second step: for every rule with a nullable nonterminal, add that rule without this nonterminal
            GrammarUtil.removeLambdaRules_StepTwo(grammar,nullable);
            GrammarUtil.removeUnneccesaryEpsilons(grammar);
            Printer.printGrammar(grammar,1);
            grammar.modifyName();
            writer.write("\t\\item[Step 3] All lambda-rules are removed and all nonterminals, that do not appear on any right side. \\\\ \n");
            GrammarUtil.removeLambdaRules_StepThree(grammar,true);
            Printer.printGrammar(grammar,1);
            grammar.clearName();
            writer.write("\\end{description}\n");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /** CONSOLE **/
    private static void printCYKTableConsole(Matrix matrix) {

    }

    private static void printRemoveLambdaRulesConsole(Grammar grammar) {
            BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(System.out));
            try {
                if(GrammarUtil.specialRuleForEmptyWord(grammar)) {
                    writer.write("added new symbol S#:\n");
                    writer.flush();
                    Printer.printGrammar(grammar);
                }
                //first step: calculate the Nullable set
                HashSet<Nonterminal> nullable= GrammarUtil.calculateNullable(grammar);
                writer.write("Step 1:\nnullable = {"+ nullable.stream().map(nt -> nt.getName()).collect(Collectors.joining(", "))+"}\n");
                writer.flush();
                writer.write("Step 2:\n");
                writer.flush();
                //second step: for every rule with a nullable nonterminal, add that rule without this nonterminal
                GrammarUtil.removeLambdaRules_StepTwo(grammar,nullable);
                GrammarUtil.removeUnneccesaryEpsilons(grammar);
                Printer.printGrammar(grammar);
                writer.write("Step 3: All lambda-rules are removed and all nonterminals, that do not appear on any right side\n");
                writer.flush();
                GrammarUtil.removeLambdaRules_StepThree(grammar,true);
                Printer.printGrammar(grammar);
                writer.flush();
            } catch (IOException e) {
                e.printStackTrace();
            }
    }

    private static void printEliminateUnitRulesConsole(Grammar grammar) {
        BufferedWriter writer1=new BufferedWriter(new OutputStreamWriter(System.out));

        try {
            HashSet<Node> unitRules=GrammarUtil.removeCircleRules(grammar);
            writer1.write("Step 1: remove circles\n");
            writer1.flush();
            Printer.printGrammar(grammar);
            writer1.write("Step 2: number the nonterminals\n");
            writer1.flush();
            ArrayList<Node> list=GrammarUtil.removeUnitRules(unitRules,grammar);
            list.stream().forEach(x -> {
                try {
                    writer1.write(x.getName() + ": " + x.getNumber() + "\n");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
            writer1.write("Step 3: remove unit rules beginning by the highest number\n");
            writer1.flush();
            Printer.printGrammar(grammar);
        } catch (IOException e) {
            e.printStackTrace();
        }


    }
    private static void printCNFConsole(Grammar grammar) {
        BufferedWriter writer1=new BufferedWriter(new OutputStreamWriter(System.out));
        try {
            writer1.write("Before:\n");
            writer1.flush();
            printGrammar(grammar);
            writer1.write("Step 1: rules in form of A --> a are already in chomsky normal form and we keep them.\n");
            writer1.flush();
            writer1.write("Step 2: in all other rules replace every appearance of Terminal a through a new Nonterminal X_a and add the rule X_a --> a\n");
            writer1.flush();
            printGrammar(grammar);
            GrammarUtil.chomskyNormalForm_StepOne(grammar);
            writer1.write("Step 3: in all rules that contain more than two nonterminals, add a new nonterminal that points to the end of the rule\n");
            writer1.flush();
            GrammarUtil.chomskyNormalForm_StepTwo(grammar);
            printGrammar(grammar);

        } catch (IOException e) {
            e.printStackTrace();
        }

    }



    /** HELP METHODS **/

    public static ArrayList<String>[] getHeader(Grammar grammar) {
        ArrayList<String>[] header=new ArrayList[3];
        header[0]=getTerminalsAsStrings(grammar);
        header[1]=getNonterminalsAsStrings(grammar);
        ArrayList<String> tmp=new ArrayList<>();
        tmp.add(grammar.getStartSymbol().getName());
        header[2]=tmp;
        return header;
    }


    private static ArrayList<String> getTerminalsAsStrings(Grammar grammar) {
        //Get all of the grammar's terminals in order of their appearance in the rules.
        ArrayList<Terminal> terminals = GrammarUtil.getTerminalsInOrder(grammar);
        return (ArrayList<String>) terminals.stream().map(terminal -> terminal.getName()).collect(Collectors.toList());
    }

    private static ArrayList<String> getNonterminalsAsStrings(Grammar grammar) {
        ArrayList<Nonterminal> nonterminals = GrammarUtil.getNonterminalsInOrder(grammar);
        return (ArrayList<String>) nonterminals.stream().map(nonterminal -> nonterminal.getName()).collect(Collectors.toList());
    }
    private static HashSet<ArrayList<String>> getRulesToNonterminal(Grammar grammar, Nonterminal nonterminal) {
        HashSet<ArrayList<Symbol>> lists=nonterminal.getSymbolLists();
        HashSet<ArrayList<String>> result=new HashSet<>();
        for(ArrayList<Symbol> list : lists) {
            result.add((ArrayList<String>)list.stream().map(symbol -> symbol.getName()).collect(toList()));
        }
        return result;
    }

}
